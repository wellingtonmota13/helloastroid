{"version":3,"sources":["../../src/schema/run-sift.js"],"names":["sift","require","_","connectionFromArray","createPageDependency","prepareRegex","Promise","trackInlineObjectsInRootNode","awaitSiftField","fields","node","k","field","resolve","fieldName","undefined","module","exports","args","nodes","type","connection","path","clonedArgs","JSON","parse","stringify","siftifyArgs","newObject","each","object","v","isObject","isArray","Minimatch","mm","makeRe","extractFieldsToSift","prekey","key","preobj","obj","val","forEach","siftArgs","fieldsToSift","filter","includes","push","resolveRecursive","siftFieldsObj","gqFields","all","keys","map","then","innerSift","innerGqConfig","getFields","myNode","resolvedFields","myNodes","index","isEmpty","indexOf","$and","nodeId","id","result","length","sort","convertedFields","replace","get","orderBy","order","connectionArray","totalCount","internal"],"mappings":"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","file":"run-sift.js","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst { connectionFromArray } = require(`graphql-skip-limit`)\nconst { createPageDependency } = require(`../redux/actions/add-page-dependency`)\nconst prepareRegex = require(`./prepare-regex`)\nconst Promise = require(`bluebird`)\nconst { trackInlineObjectsInRootNode } = require(`../redux`)\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    return field.resolve(node, {}, {}, { fieldName: k })\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n/*\n* Filters a list of nodes using mongodb-like syntax.\n* Returns a single unwrapped element if connection = false.\n*\n*/\nmodule.exports = ({\n  args,\n  nodes,\n  type,\n  connection = false,\n  path = ``,\n}: Object) => {\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const clonedArgs = JSON.parse(JSON.stringify(args))\n\n  const siftifyArgs = object => {\n    const newObject = {}\n    _.each(object, (v, k) => {\n      if (_.isObject(v) && !_.isArray(v)) {\n        newObject[k] = siftifyArgs(v)\n      } else {\n        // Compile regex first.\n        if (k === `regex`) {\n          newObject[`$regex`] = prepareRegex(v)\n        } else if (k === `glob`) {\n          const Minimatch = require(`minimatch`).Minimatch\n          const mm = new Minimatch(v)\n          newObject[`$regex`] = mm.makeRe()\n        } else {\n          newObject[`$${k}`] = v\n        }\n      }\n    })\n    return newObject\n  }\n\n  // Build an object that excludes the innermost leafs,\n  // this avoids including { eq: x } when resolving fields.\n  function extractFieldsToSift(prekey, key, preobj, obj, val) {\n    if (_.isObject(val) && !_.isArray(val)) {\n      _.forEach((val: any), (v, k) => {\n        preobj[prekey] = obj\n        extractFieldsToSift(key, k, obj, {}, v)\n      })\n    } else {\n      preobj[prekey] = true\n    }\n  }\n\n  const siftArgs = []\n  const fieldsToSift = {}\n  if (clonedArgs.filter) {\n    _.each(clonedArgs.filter, (v, k) => {\n      // Ignore connection and sorting args.\n      if (_.includes([`skip`, `limit`, `sort`], k)) return\n\n      siftArgs.push(siftifyArgs({ [k]: v }))\n      extractFieldsToSift(``, k, {}, fieldsToSift, v)\n    })\n  }\n\n  // Resolves every field used in the sift.\n  function resolveRecursive(node, siftFieldsObj, gqFields) {\n    return Promise.all(\n      _.keys(siftFieldsObj).map(k =>\n        Promise.resolve(awaitSiftField(gqFields, node, k))\n          .then(v => {\n            const innerSift = siftFieldsObj[k]\n            const innerGqConfig = gqFields[k]\n            if (_.isObject(innerSift) && v != null) {\n              return resolveRecursive(\n                v,\n                innerSift,\n                innerGqConfig.type.getFields()\n              )\n            } else {\n              return v\n            }\n          })\n          .then(v => [k, v])\n      )\n    ).then(resolvedFields => {\n      const myNode = { ...node }\n      resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n      return myNode\n    })\n  }\n\n  return Promise.all(\n    nodes.map(node => resolveRecursive(node, fieldsToSift, type.getFields()))\n  ).then(myNodes => {\n    myNodes = myNodes.map(trackInlineObjectsInRootNode)\n    if (!connection) {\n      const index = _.isEmpty(siftArgs)\n        ? 0\n        : sift.indexOf({ $and: siftArgs }, myNodes)\n\n      // If a node is found, create a dependency between the resulting node and\n      // the path.\n      if (index !== -1) {\n        createPageDependency({\n          path,\n          nodeId: myNodes[index].id,\n        })\n\n        return myNodes[index]\n      } else {\n        return null\n      }\n    }\n\n    let result = _.isEmpty(siftArgs)\n      ? myNodes\n      : sift({ $and: siftArgs }, myNodes)\n\n    if (!result || !result.length) return null\n\n    // Sort results.\n    if (clonedArgs.sort) {\n      // create functions that return the item to compare on\n      // uses _.get so nested fields can be retrieved\n      const convertedFields = clonedArgs.sort.fields\n        .map(field => field.replace(/___/g, `.`))\n        .map(field => v => _.get(v, field))\n\n      result = _.orderBy(result, convertedFields, clonedArgs.sort.order)\n    }\n\n    const connectionArray = connectionFromArray(result, args)\n    connectionArray.totalCount = result.length\n    if (result.length > 0 && result[0].internal) {\n      createPageDependency({\n        path,\n        connection: result[0].internal.type,\n      })\n    }\n    return connectionArray\n  })\n}\n"]}